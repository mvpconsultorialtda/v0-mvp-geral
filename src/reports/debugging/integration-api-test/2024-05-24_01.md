
# Relatório de Depuração de Teste de Integração de API

**Data:** 24 de Maio de 2024

**Autor:** Assistente de IA Gemini

## 1. Objetivo

O objetivo era criar um teste de integração para o fluxo de criação de listas de tarefas e tarefas associadas. O teste deveria simular uma requisição de API para criar uma lista, seguida por uma requisição para adicionar uma tarefa a essa lista, validando uma resposta de sucesso (status 201) em ambas as etapas.

## 2. O Problema: Falha Persistente de Permissão (403 Forbidden)

O teste falhou consistentemente na segunda etapa: a criação da tarefa. A API retornava um status `403 Forbidden`, indicando que o usuário autenticado não tinha permissão para adicionar uma tarefa à lista recém-criada.

O ponto exato da falha foi identificado no manipulador `POST` em `app/api/todo-lists/[listId]/tasks/route.ts`:

```typescript
const list = await getTodoListById(listId);
// ...
const ability = defineAbilitiesFor(user);
if (ability.cannot('update', list)) { // <-- Esta verificação falhou
  return NextResponse.json({ message: "Forbidden" }, { status: 403 });
}
```

A verificação `ability.cannot('update', list)` retornava `true`, bloqueando o fluxo.

## 3. Cronologia da Depuração e Hipóteses

A investigação seguiu uma série de hipóteses, cada uma levando a uma correção na configuração do teste, mas nenhuma resolvendo o problema raiz.

### Hipótese 1: Problemas com Aliases e Simulação do Firestore

*   **Observação:** O teste estava falhando inicialmente devido a problemas na resolução de caminhos (`@/`) e na simulação (mock) do módulo `firebase-admin`.
*   **Ação:** Corrigimos o `jest.config.js` para usar o `moduleNameMapper` e movemos a simulação do Firebase para um arquivo de configuração global (`jest.setup.ts`), garantindo que ele fosse executado antes de todos os testes.
*   **Resultado:** Os erros de resolução de módulo foram corrigidos, mas o erro `403` persistiu.

### Hipótese 2: Simulação Incorreta da Verificação de Sessão

*   **Observação:** A verificação de sessão (`verifySession`) poderia não estar retornando um usuário válido durante a execução do teste.
*   **Ação:** Implementamos uma simulação explícita do módulo `@/lib/session`, garantindo que `verifySession` sempre resolvesse com um objeto de usuário válido (`{ uid: 'user-123' }`).
*   **Resultado:** A simulação da sessão funcionou corretamente, mas o erro `403` persistiu.

### Hipótese 3: Incompatibilidade entre Dados Simulados e Regras de Permissão (CASL)

*   **Observação:** O erro `403` vinha diretamente do sistema de controle de acesso (CASL). A hipótese era que o objeto `list` simulado não satisfazia as regras de permissão.
*   **Ação:** Lemos o arquivo de definição de habilidades (`src/modules/access-control/ability.ts`). Descobrimos a regra crucial para atualização:

    ```typescript
    // Usuários podem 'gerenciar' (fazer tudo) nas listas que possuem.
    can('manage', 'TodoList', { ownerId: { $eq: user.uid } });
    ```

    A regra exigia um campo `ownerId` no objeto da lista. A nossa simulação do Firestore em `jest.setup.ts` estava fornecendo um campo `owner`.

*   **Ação Corretiva:** Modificamos a simulação para retornar `{ name: '...', ownerId: 'user-123' }`.
*   **Resultado:** A lógica parecia sólida, mas, para nossa surpresa, o erro `403` persistiu.

### Hipótese 4: Incompatibilidade Estrutural do Objeto Simulado (A Falha Final)

*   **Observação:** Se a regra e os dados do proprietário estavam corretos, então o próprio objeto `list`, como entendido pelo CASL, deveria estar malformado ou incompleto.
*   **Ação:** Inspecionamos a função `getTodoListById` em `src/modules/todo-list/core.server.ts`.

    ```typescript
    export async function getTodoListById(listId: string): Promise<TodoList | null> {
      const doc = await docRef.get();
      // ...
      return { id: doc.id, ...doc.data() } as TodoList;
    }
    ```

    A função não retorna apenas `doc.data()`, mas constrói um novo objeto que inclui `id: doc.id`.

*   **Análise da Falha:** A nossa simulação do Firestore, embora retornasse o `ownerId` correto, não tinha uma propriedade `id` no objeto de snapshot simulado (`mockDocSnapshot`). Portanto, `doc.id` era `undefined`, e a função `getTodoListById` estava, na verdade, passando `{ id: undefined, ownerId: 'user-123', ... }` para a verificação de permissão. O CASL provavelmente rejeitava este objeto por ser inválido ou malformado.

*   **Ação Corretiva Final:** Reescrevemos a simulação em `jest.setup.ts` para ser mais precisa. A função `doc(docId)` simulada passou a retornar um objeto snapshot que continha o mesmo `docId`.

    ```javascript
    // jest.setup.ts corrigido
    doc: jest.fn((docId) => ({
      get: jest.fn().mockResolvedValue({
        id: docId, // <-- A correção crucial
        exists: true,
        data: () => ({ ownerId: 'user-123' })
      })
    }))
    ```

*   **Resultado:** O erro `403 Forbidden` persistiu, mesmo após esta correção aparentemente definitiva.

## 4. Conclusão e Próximos Passos

A persistência do erro `403` após a correção da Hipótese 4 indica que há uma sutileza na interação entre a simulação do Jest, o sistema de tipos do TypeScript, a inferência de "assunto" do CASL e a lógica de negócios, que não foi capturada por esta análise estática.

O modelo mental construído através da leitura dos arquivos provou ser incompleto ou falho. A causa raiz permanece desconhecida, e continuar a modificar a simulação "às cegas" é ineficiente.

**Recomendação:**

A única maneira confiável de diagnosticar o problema é através da depuração em tempo de execução. Recomenda-se o seguinte:

1.  **Inserir `console.log` Estratégicos:** Antes da linha `if (ability.cannot('update', list))`, adicione logs para inspecionar os seguintes objetos em tempo de execução do teste:
    *   `console.log('Objeto List:', JSON.stringify(list, null, 2));`
    *   `console.log('Objeto User:', JSON.stringify(user, null, 2));`
    *   `console.log('Regras de Habilidade (JSON):', JSON.stringify(ability.rules, null, 2));`

2.  **Analisar a Saída:** A saída desses logs no console durante a execução de `pnpm exec jest` revelará exatamente com o que cada parte do sistema está trabalhando, expondo a incompatibilidade final que tem nos escapado.

Este processo de depuração, embora frustrante, foi valioso para expor a complexidade e a fragilidade dos testes de integração em um sistema com múltiplas camadas de abstração (ORM/DB Abstraction, Controle de Acesso, Mocks de Teste).
